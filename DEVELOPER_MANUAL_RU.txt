================================================================================
              ТЕЛЕГРАМ-БОТ ДОДО ПИЦЦА - ТЕХНИЧЕСКАЯ ДОКУМЕНТАЦИЯ
================================================================================

Версия: 1.0
Последнее обновление: 27 ноября 2025
Назначение: Техническая документация для разработчиков

================================================================================
                    ТЕХНИЧЕСКАЯ ДОКУМЕНТАЦИЯ ДЛЯ РАЗРАБОТЧИКОВ
================================================================================

Этот раздел предназначен для разработчиков, которые поддерживают, модифицируют
или развертывают бота.

--------------------------------------------------------------------------------
1. АРХИТЕКТУРА СИСТЕМЫ
--------------------------------------------------------------------------------

1.1 ТЕХНОЛОГИЧЕСКИЙ СТЕК
------------------------
- Язык: Python 3.10+
- Фреймворк: python-telegram-bot (v20+)
- Веб-фреймворк: Flask + Gunicorn
- База данных: Google Sheets (через gspread)
- ИИ: Google Gemini API
- Развертывание: Ubuntu 24.04, systemd
- Менеджер процессов: systemd services

1.2 СТРУКТУРА ПРОЕКТА
---------------------
dodo_bot/
├── main.py                      # Точка входа бота, регистрация обработчиков
├── config.py                    # Загрузчик переменных окружения
├── requirements.txt             # Зависимости Python
├── .env                         # Переменные окружения (не в git)
├── service_account.json         # Учетные данные Google (не в git)
│
├── handlers/                    # Обработчики команд Telegram
│   ├── start.py                # Регистрация, команда /start
│   ├── menu.py                 # Маршрутизация главного меню
│   ├── preps.py                # Диалог заготовок
│   ├── defrost.py              # Диалог разморозки
│   ├── schedule.py             # Отображение графика
│   ├── medical.py              # Управление медицинской комиссией
│   ├── ratings.py              # Загрузка/отображение фотографий рейтингов
│   ├── wages.py                # Информация о зарплате
│   ├── lunch.py                # Информация об обеденном перерыве
│   ├── worker_instructions.py  # Меню инструкций для сотрудников
│   ├── group_setup.py          # Групповые команды (/set_group, /prep, /who)
│   └── message_handler.py      # Сбор сообщений/фото для обратной связи
│
├── services/                    # Слой бизнес-логики
│   ├── sheets.py               # Интеграция с Google Sheets
│   ├── scheduler.py            # Планировщик заданий для уведомлений
│   ├── auth.py                 # Аутентификация и авторизация
│   ├── medical_service.py      # Управление медицинскими данными
│   ├── feedback_analyzer.py    # ИИ-анализ обратной связи
│   ├── message_collector.py    # Сервис сбора сообщений
│   └── sheet_manager.py        # Кэширование данных таблиц
│
├── web_app/                     # Веб-приложение Flask
│   ├── app.py                  # Точка входа веб-приложения
│   ├── templates/              # HTML-шаблоны
│   │   └── preps.html         # Страница отображения заготовок
│   └── static/                 # CSS, JS, изображения
│
├── data/                        # JSON файлы данных (runtime)
│   ├── users.json              # Регистрации пользователей
│   ├── group.json              # Группа для уведомлений
│   ├── medical_info.json       # Медицинские записи
│   ├── ratings_rs.json         # Фотографии рейтинга сервиса
│   ├── ratings_rp.json         # Фотографии рейтинга продукции
│   ├── daily_messages.json     # Ежедневный сбор сообщений
│   └── daily_photos.json       # Ежедневный сбор фотографий
│
├── logs/                        # Логи приложения
│   ├── dodo_bot.log            # Основной лог бота (с ротацией)
│   ├── dodo_bot_errors.log     # Лог ошибок (с ротацией)
│   └── webapp.log              # Лог веб-приложения
│
├── deployment/                  # Файлы развертывания
│   ├── dodo-bot.service        # Systemd сервис для бота
│   ├── dodo-webapp.service     # Systemd сервис для веб-приложения
│   ├── setup.sh                # Скрипт начальной настройки
│   ├── update.sh               # Скрипт обновления
│   ├── backup.sh               # Скрипт резервного копирования
│   └── start.sh                # Скрипт ручного запуска
│
├── .github/workflows/           # CI/CD пайплайны
│   └── deploy.yml              # Развертывание через GitHub Actions
│
└── docs/                        # Документация
    ├── README.md               # Обзор проекта
    ├── DEPLOYMENT.md           # Руководство по развертыванию
    ├── MAINTENANCE.md          # Руководство по обслуживанию
    ├── USER_MANUAL.txt         # Руководство пользователя (англ.)
    ├── USER_MANUAL_RU.txt      # Руководство пользователя (рус.)
    └── DEVELOPER_MANUAL_RU.txt # Этот файл


1.3 ПОТОК ДАННЫХ
----------------

Ввод пользователя → Telegram API → Обработчики бота → Сервисы → Источники данных
                                                                  ↓
                                                  ┌───────────────┴────────────┐
                                                  │                            │
                                            Google Sheets                  JSON файлы
                                            (Только чтение)              (Чтение/Запись)
                                                  │                            │
                                                  └───────────────┬────────────┘
                                                                  ↓
                                                          Ответ пользователю


1.4 ПОТОК АУТЕНТИФИКАЦИИ
-------------------------

1. Пользователь отправляет /start
2. Бот проверяет data/users.json на наличие user_id
3. Если не найден:
   a. Получить список сотрудников из Google Sheets
   b. Отобразить inline-клавиатуру с именами
   c. Пользователь выбирает имя
   d. Сохранить связь user_id → фамилия
4. Если найден:
   a. Показать приветственное сообщение с фамилией
   b. Отобразить главное меню

Авторизация менеджера:
1. Проверить, есть ли фамилия в списке ADMIN_SURNAMES
2. ИЛИ проверить, role == "manager" в medical_info.json
3. ИЛИ проверить, является ли администратором группы Telegram (для групповых команд)


--------------------------------------------------------------------------------
2. ОСНОВНЫЕ КОМПОНЕНТЫ
--------------------------------------------------------------------------------

2.1 MAIN.PY - ТОЧКА ВХОДА ПРИЛОЖЕНИЯ
-------------------------------------

Назначение: Инициализация бота, регистрация обработчиков, запуск polling

Ключевые функции:
- signal_handler(): Корректное завершение при SIGTERM/SIGINT
- Конфигурация логирования с ротацией
- Регистрация обработчиков в определенном порядке
- Инициализация очереди заданий для запланированных задач

Порядок регистрации обработчиков:
1. Обработчик ограничения группы (group=-1, наивысший приоритет)
2. Обработчики start и регистрации
3. Обработчики функций (preps, defrost, wages и т.д.)
4. Обработчик диалога medical
5. Обработчики ratings
6. Обработчик callback schedule
7. Обработчик сообщений menu (catch-all)
8. Обработчики групповых команд (/set_group, /prep, /who, /rs, /rp)
9. Обработчики сбора сообщений (group=10, наименьший приоритет)

Запланированные задания:
- check_shifts_and_notify: Каждые 5 минут
- send_preps_notification: 8:55, 16:55 (Москва)
- send_who_notification: 8:00 (Москва)
- send_feedback_notification: 23:05 (Москва)
- reset_daily_data_job: Полночь (Москва)

Необходимые переменные окружения:
- BOT_TOKEN: Токен Telegram бота
- GOOGLE_SERVICE_ACCOUNT_FILE: Путь к JSON сервисного аккаунта
- SPREADSHEET_ID: ID Google Sheets
- GEMINI_API_KEY: Ключ API Gemini


2.2 HANDLERS/ - ОБРАБОТЧИКИ КОМАНД TELEGRAM
--------------------------------------------

start.py
--------
Экспортирует: start_handler, registration_handler

Функции:
- start(): Точка входа, показывает список сотрудников или меню
- button_handler(): Обрабатывает callback регистрации
- show_menu(): Отображает главное меню с клавиатурой

Файлы данных:
- Читает/Записывает: data/users.json

Структура данных пользователя:
{
  "user_id": "фамилия"
}


menu.py
-------
Экспортирует: menu_message_handler

Функции:
- menu_handler(): Маршрутизирует нажатия кнопок меню

Маршрутизация:
- "График" → schedule_handler
- "Главное меню" / "Назад" → show_menu
- Другие кнопки обрабатываются соответствующими ConversationHandlers


preps.py
--------
Экспортирует: preps_handler (ConversationHandler)

Состояния:
- SHIFT_SELECTION: Выбор утренней или вечерней смены

Функции:
- preps_menu(): Точка входа
- shift_selection(): Обработка выбора смены
- cancel(): Выход из диалога

Источник данных: Лист "Заготовки" в Google Sheets


defrost.py
----------
Экспортирует: defrost_handler (ConversationHandler)

Состояния:
- SECTION_SELECTION: Выбор раздела морозилки

Функции:
- defrost_menu(): Точка входа
- section_selection(): Обработка выбора раздела
- cancel(): Выход из диалога

Источник данных: Лист "Разморозка" в Google Sheets


schedule.py
-----------
Экспортирует: schedule_callback_handler

Функции:
- schedule_handler(): Точка входа, показывает кнопки диапазона дат
- schedule_button_handler(): Обработка выбора диапазона дат
- Вспомогательные функции для расчета дат

Источник данных: Лист "График" в Google Sheets


medical.py
----------
Экспортирует: medical_handlers (список)

Компоненты:
- medical_menu_handler: Точка входа
- medical_conv_handler: Диалог редактирования
- medical_button_handler: Callback просмотра

Состояния:
- SELECT_EMPLOYEE: Выбор сотрудника для редактирования
- SELECT_TYPE: Выбор мед. комиссии или сан. минимума
- INPUT_DATE: Ввод новой даты

Функции:
- medical_menu(): Показать главное меню медицины
- medical_button_handler(): Обработка просмотра всех/просроченных
- start_edit(): Начать процесс редактирования (только менеджер)
- select_employee(): Выбрать сотрудника
- select_type(): Выбрать тип данных
- input_date(): Проверить и сохранить дату
- cancel_date_input(): Отменить во время ввода даты

Авторизация:
- ADMIN_SURNAMES: Жестко заданные фамилии менеджеров
- is_manager(): Проверка роли в medical_info.json

Файлы данных:
- Читает/Записывает: data/medical_info.json

Структура медицинской информации:
{
  "employees": [
    {
      "name": "Фамилия",
      "role": "manager|pizzamaker|cashier|courier|universal|mentor|instructor|trainee",
      "med_commission_date": "ДД.ММ.ГГГГ",
      "san_min_date": "ДД.ММ.ГГГГ",
      "status": "missing_docs" (опционально)
    }
  ]
}


ratings.py
----------
Экспортирует: 
- ratings_message_handler
- upload_rs_handler (ConversationHandler)
- upload_rp_handler (ConversationHandler)
- rs_command_handler
- rp_command_handler

Состояния (для загрузки):
- UPLOAD_PHOTOS: Получение фотографий

Функции:
- ratings_menu(): Показать текущие рейтинги
- start_upload_rs/rp(): Начать загрузку (только менеджер)
- receive_photos_rs/rp(): Сохранить фотографии
- rs_command/rp_command(): Показать рейтинги в группе (только менеджер)

Файлы данных:
- Читает/Записывает: data/ratings_rs.json, data/ratings_rp.json

Структура рейтингов:
{
  "photos": ["file_id_1", "file_id_2"]
}


worker_instructions.py
----------------------
Экспортирует:
- worker_instructions_message_handler
- instructions_callback

Функции:
- worker_instructions_handler(): Точка входа
- instructions_callback_handler(): Навигация по дереву инструкций
- edit_menu(): Вспомогательная функция для обновления меню
- show_content(): Вспомогательная функция для показа контента с кнопкой назад

Структура меню:
Корень
├── Кассовая зона
│   ├── Касса
│   │   ├── Открытие смены
│   │   ├── В течение дня
│   │   └── Закрытие смены
│   └── Упаковка
│       ├── Открытие смены
│       └── В течение дня
└── Пицца
    ├── Горячий цех
    │   ├── Открытие смены
    │   ├── В течение дня
    │   └── Закрытие смены
    └── Холодный цех
        ├── Открытие смены
        ├── В течение дня
        └── Закрытие смены


group_setup.py
--------------
Экспортирует: 
- set_group_handler (CommandHandler)
- prep_command_handler (CommandHandler)
- who_command_handler (CommandHandler)

Функции:
- set_group_handler(): Сохранить ID группы для уведомлений
- prep_command_handler(): Показать заготовки следующей смены
- who_command_handler(): Показать сегодняшних работников

Файлы данных:
- Записывает: data/group.json

Структура группы:
{
  "group_id": "chat_id"
}


message_handler.py
------------------
Экспортирует:
- text_collection_handler
- photo_collection_handler

Функции:
- collect_text_message(): Сохранить текстовые сообщения из группы
- collect_photo_message(): Сохранить ID файлов фотографий из группы

Файлы данных:
- Записывает: data/daily_messages.json, data/daily_photos.json

Сбор работает только в групповых чатах, не в личных.


2.3 SERVICES/ - БИЗНЕС-ЛОГИКА
------------------------------

sheets.py
---------
Назначение: Интеграция с Google Sheets

Ключевые функции:
- get_all_employees(): Получить список сотрудников из "График"
- get_schedule(date_range): Получить график для диапазона дат
- get_preps(day_index, is_morning): Получить список заготовок
- get_defrost_items(section): Получить продукты для разморозки
- get_wages_info(): Получить информацию о зарплате
- get_lunch_info(): Получить информацию об обеде
- get_who_on_shift(date_str): Получить сегодняшних работников

Реализация:
- Использует библиотеку gspread
- Аутентификация через сервисный аккаунт
- Кэширует объекты рабочих листов
- Обрабатывает ограничения скорости API
- Парсит данные таблиц в структурированный формат

Требования к формату таблиц:
- "График": Столбцы для даты, сотрудника, времени смен
- "Заготовки": Столбцы для типа смены, дня, продуктов
- "Разморозка": Разделы для разных этажей
- "Зарплата": Форматированный текст
- "Обед": Форматированный текст


scheduler.py
------------
Назначение: Запланированные задания уведомлений

Ключевые функции:
- check_shifts_and_notify(context): Проверка предстоящих смен, отправка напоминаний
- send_preps_notification(context): Отправка списка заготовок в группу
- send_who_notification(context): Отправка списка сегодняшних работников в группу
- send_feedback_notification(context): Отправка сводки обратной связи, проанализированной ИИ
- reset_daily_data_job(context): Очистка ежедневных коллекций сообщений/фото

Реализация:
- Использует JobQueue из python-telegram-bot
- Работает в отдельных потоках
- Читает group_id из data/group.json
- Отправляет сообщения в групповой чат
- Корректно обрабатывает ошибки

Логика уведомлений:
- Напоминания о сменах: За 1 час до начала смены
- Заготовки: Определяется временем дня (утро/вечер)
- Кто работает: На основе сегодняшней даты
- Обратная связь: Агрегирует все сообщения за день


auth.py
-------
Назначение: Аутентификация и авторизация

Ключевые функции:
- is_user_admin(update, context): Проверка, является ли администратором группы Telegram
- get_user_role(user_id, context): Получить роль пользователя из medical_info.json
- is_manager(surname): Проверить, является ли фамилия менеджером

Используется:
- main.py: Обработчик ограничения группы
- medical.py: Права на редактирование
- ratings.py: Права на загрузку
- Групповые команды: Ограничения команд


medical_service.py
------------------
Назначение: Управление медицинскими данными

Ключевые функции:
- load_medical_data(): Чтение medical_info.json
- save_medical_data(data): Запись medical_info.json
- update_employee_medical_info(name, med_date, san_date): Обновление дат
- get_employee_status(name): Получить медицинский статус сотрудника
- get_all_medical_issues(): Получить список просроченных/истекающих документов
- is_manager(surname): Проверить роль менеджера

Логика истечения:
- Просрочено: Дата в прошлом
- Скоро истекает: Дата в течение 30 дней
- Отсутствует: Нет даты или status == "missing_docs"


feedback_analyzer.py
--------------------
Назначение: ИИ-анализ обратной связи

Ключевые функции:
- analyze_feedback(messages, photos): Отправка в Gemini API для анализа

Реализация:
- Использует Google Gemini API
- Отправляет текстовые сообщения и ID файлов фотографий
- Получает структурированный анализ
- Обрабатывает ошибки API

Анализ включает:
- Сводку ключевых проблем
- Жалобы клиентов
- Проблемы с качеством
- Проблемы с обслуживанием
- Положительные моменты
- Пункты действий


message_collector.py
--------------------
Назначение: Сбор и управление ежедневными сообщениями/фото

Ключевые функции:
- save_message(user, text): Сохранить текстовое сообщение
- save_photo(user, file_id): Сохранить ID файла фотографии
- get_all_messages(): Получить все сообщения
- get_all_photos(): Получить все ID файлов фотографий
- reset_daily_data(): Очистить коллекции

Файлы данных:
- data/daily_messages.json
- data/daily_photos.json

Структура:
{
  "messages": [
    {"user": "Имя", "text": "Сообщение", "timestamp": "ISO8601"}
  ]
}


sheet_manager.py
----------------
Назначение: Слой кэширования для Google Sheets

Ключевые функции:
- get_cached_sheet(sheet_name): Получить рабочий лист с кэшированием
- invalidate_cache(): Очистить кэш

Реализация:
- Кэширует объекты рабочих листов
- Уменьшает количество вызовов API
- Истечение на основе TTL


2.4 WEB_APP/ - ВЕБ-ПРИЛОЖЕНИЕ FLASK
------------------------------------

app.py
------
Назначение: Веб-интерфейс для просмотра заготовок

Endpoints:
- GET /: Показать список заготовок для текущей смены
- GET /health: Endpoint проверки здоровья

Реализация:
- Приложение Flask
- Читает из Google Sheets
- Адаптивный HTML-шаблон
- Автоматическое обновление данных

Развертывание:
- Работает на порту 5001
- Обслуживается Gunicorn
- Systemd сервис: dodo-webapp.service

Использование:
- Отображение на планшете на кухне
- Показывает заготовки текущей смены
- Не требует аутентификации (внутренняя сеть)


templates/preps.html
--------------------
Назначение: Отображение заготовок в веб-формате

Функции:
- Адаптивный дизайн
- Крупный, читаемый текст
- Цветные разделы
- Опция автообновления
- Дружественный к мобильным устройствам


--------------------------------------------------------------------------------
3. РАЗВЕРТЫВАНИЕ
--------------------------------------------------------------------------------

3.1 СИСТЕМНЫЕ ТРЕБОВАНИЯ
-------------------------
- ОС: Ubuntu 24.04 LTS
- Python: 3.10+
- RAM: Минимум 512MB, рекомендуется 1GB
- Диск: Минимум 1GB
- Сеть: Исходящий HTTPS (443) для API

3.2 ПРОЦЕСС УСТАНОВКИ
----------------------

Шаг 1: Клонирование репозитория
git clone <repo-url> /home/ubuntu/dodo_bot
cd /home/ubuntu/dodo_bot

Шаг 2: Создание виртуального окружения
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

Шаг 3: Настройка окружения
Создать файл .env:
BOT_TOKEN=ваш_токен_бота
GOOGLE_SERVICE_ACCOUNT_FILE=service_account.json
SPREADSHEET_ID=ваш_id_таблицы
GEMINI_API_KEY=ваш_ключ_gemini

Скопировать service_account.json в корень проекта

Шаг 4: Создание директорий
mkdir -p logs data

Шаг 5: Установка Systemd сервисов
sudo cp deployment/dodo-bot.service /etc/systemd/system/
sudo cp deployment/dodo-webapp.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable dodo-bot dodo-webapp
sudo systemctl start dodo-bot dodo-webapp

Шаг 6: Проверка
sudo systemctl status dodo-bot
sudo systemctl status dodo-webapp
curl http://localhost:5001/health


3.3 SYSTEMD СЕРВИСЫ
-------------------

dodo-bot.service
----------------
[Unit]
Description=Dodo Pizza Telegram Bot
After=network.target

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/dodo_bot
Environment="PATH=/home/ubuntu/dodo_bot/venv/bin"
ExecStart=/home/ubuntu/dodo_bot/venv/bin/python main.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target


dodo-webapp.service
-------------------
[Unit]
Description=Dodo Pizza Web App
After=network.target

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/dodo_bot/web_app
Environment="PATH=/home/ubuntu/dodo_bot/venv/bin"
ExecStart=/home/ubuntu/dodo_bot/venv/bin/gunicorn -w 2 -b 0.0.0.0:5001 app:app
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target


3.4 ЛОГИРОВАНИЕ
---------------

Файлы логов:
- /home/ubuntu/dodo_bot/logs/dodo_bot.log - Основной лог бота
- /home/ubuntu/dodo_bot/logs/dodo_bot_errors.log - Лог ошибок
- /home/ubuntu/dodo_bot/logs/webapp.log - Лог веб-приложения

Ротация:
- Максимальный размер: 10MB на файл
- Резервные копии: Хранится 5 файлов
- Автоматическая ротация через Python logging

Логи Systemd:
- sudo journalctl -u dodo-bot -f
- sudo journalctl -u dodo-webapp -f


3.5 СТРАТЕГИЯ РЕЗЕРВНОГО КОПИРОВАНИЯ
-------------------------------------

Автоматическое резервное копирование (deployment/backup.sh):
- Выполняется ежедневно в 3 часа ночи (через cron)
- Резервирует:
  * Директорию data/ (все JSON файлы)
  * Файл .env
  * service_account.json
  * Последние логи (за последние 7 дней)
- Хранится в: /home/ubuntu/dodo_bot_backups/
- Имя файла: backup_YYYYMMDD_HHMMSS.tar.gz

Запись Cron:
0 3 * * * /home/ubuntu/dodo_bot/deployment/backup.sh >> /home/ubuntu/dodo_bot/logs/backup.log 2>&1

Процесс восстановления:
1. Остановить сервисы
2. Извлечь резервную копию
3. Скопировать файлы в директорию проекта
4. Перезапустить сервисы


3.6 ПРОЦЕСС ОБНОВЛЕНИЯ
----------------------

Автоматическое обновление (deployment/update.sh):
1. Создать резервную копию
2. Получить последний код из git
3. Активировать виртуальное окружение
4. Обновить зависимости
5. Перезапустить сервисы
6. Показать статус

Ручное обновление:
./deployment/backup.sh
git pull origin main
source venv/bin/activate
pip install -r requirements.txt --upgrade
sudo systemctl restart dodo-bot dodo-webapp


3.7 CI/CD ПАЙПЛАЙН
------------------

GitHub Actions (.github/workflows/deploy.yml):

Триггеры:
- Push в ветку main

Шаги:
1. Checkout кода
2. Подключение к серверу через SSH
3. Pull последнего кода
4. Создание .env из секретов
5. Создание service_account.json из секретов
6. Запуск update.sh
7. Проверка работы сервисов

Необходимые секреты:
- HOST: IP сервера
- USERNAME: Имя пользователя SSH
- SSH_KEY: Приватный ключ
- BOT_TOKEN: Токен Telegram бота
- SPREADSHEET_ID: ID Google Sheets
- GEMINI_API_KEY: Ключ API Gemini
- GOOGLE_CREDENTIALS: JSON сервисного аккаунта


--------------------------------------------------------------------------------
4. РУКОВОДСТВО ПО РАЗРАБОТКЕ
--------------------------------------------------------------------------------

4.1 НАСТРОЙКА СРЕДЫ РАЗРАБОТКИ
-------------------------------

1. Клонировать репозиторий
2. Создать виртуальное окружение
3. Установить зависимости
4. Создать .env с тестовыми учетными данными
5. Запустить локально: python main.py

Тестирование:
- Создать тестового Telegram бота
- Использовать тестовую Google таблицу
- Тестировать Gemini API отдельно


4.2 РЕКОМЕНДАЦИИ ПО СТРУКТУРЕ КОДА
-----------------------------------

Обработчики:
- Один файл на функцию
- Экспортировать объекты обработчиков (не функции)
- Использовать ConversationHandler для многошаговых процессов
- Корректно обрабатывать ошибки
- Всегда предоставлять опции "назад" или "отмена"

Сервисы:
- Чистая бизнес-логика
- Без прямых вызовов Telegram API
- Возвращать данные, а не сообщения
- Обрабатывать ошибки внешних API
- Использовать кэширование где уместно

Файлы данных:
- Формат JSON
- Кодировка UTF-8
- Атомарная запись (запись во временный файл, затем переименование)
- Проверка структуры при чтении


4.3 ДОБАВЛЕНИЕ НОВЫХ ФУНКЦИЙ
-----------------------------

Пример: Добавление нового пункта меню

Шаг 1: Создать файл обработчика
handlers/new_feature.py

Шаг 2: Реализовать функции обработчика
async def new_feature_handler(update, context):
    # Реализация
    pass

Шаг 3: Экспортировать обработчик
new_feature_handler = MessageHandler(filters.Regex("^Новая функция$"), new_feature_handler)

Шаг 4: Зарегистрировать в main.py
from handlers.new_feature import new_feature_handler
application.add_handler(new_feature_handler)

Шаг 5: Добавить кнопку в меню
В handlers/start.py добавить кнопку в клавиатуру:
["Новая функция", "Другая кнопка"]


4.4 МОДИФИКАЦИЯ ИНТЕГРАЦИИ С GOOGLE SHEETS
-------------------------------------------

Добавление нового листа:
1. Добавить имя листа в sheets.py
2. Создать функцию для чтения листа
3. Парсить данные в структурированный формат
4. Обрабатывать отсутствующие/неправильные данные
5. Кэшировать, если часто используется

Пример:
async def get_new_data():
    gc = get_sheets_client()
    sheet = gc.open_by_key(SPREADSHEET_ID)
    worksheet = sheet.worksheet("НовыйЛист")
    data = worksheet.get_all_records()
    return process_data(data)


4.5 МОДИФИКАЦИЯ УВЕДОМЛЕНИЙ
----------------------------

Добавление нового запланированного уведомления:
1. Создать функцию в services/scheduler.py
2. Добавить задание в main.py:
   application.job_queue.run_daily(new_notification, time(час, минута, tzinfo=tz))

Изменение времени уведомления:
- Отредактировать time() в регистрации задания в main.py
- Перезапустить бота


4.6 ПАТТЕРНЫ ОБРАБОТКИ ОШИБОК
------------------------------

Try-Except в обработчиках:
try:
    # Операция
    await update.message.reply_text("Успешно")
except Exception as e:
    logger.error(f"Ошибка: {e}", exc_info=True)
    await update.message.reply_text("❌ Ошибка. Попробуйте позже.")

Обработка ошибок Callback Query:
try:
    await query.answer()
except Exception as e:
    logger.warning(f"Не удалось ответить на callback: {e}")
    # Продолжить обработку

Обработка ошибок API:
try:
    data = await external_api_call()
except APIError as e:
    logger.error(f"Ошибка API: {e}")
    return default_value


4.7 РЕКОМЕНДАЦИИ ПО ТЕСТИРОВАНИЮ
---------------------------------

Модульные тесты:
- Тестировать функции сервисов независимо
- Мокировать внешние API
- Тестировать граничные случаи

Интеграционные тесты:
- Тестировать потоки обработчиков
- Использовать тестового бота и тестовую группу
- Проверять сохранение данных

Чек-лист ручного тестирования:
□ Поток регистрации
□ Все кнопки меню
□ Каждый поток диалога
□ Групповые команды
□ Запланированные уведомления
□ Сценарии ошибок
□ Проверки прав доступа


--------------------------------------------------------------------------------
5. УСТРАНЕНИЕ НЕПОЛАДОК
--------------------------------------------------------------------------------

5.1 ЧАСТЫЕ ПРОБЛЕМЫ
-------------------

Бот не отвечает:
- Проверить systemctl status dodo-bot
- Проверить логи: sudo journalctl -u dodo-bot -n 100
- Проверить BOT_TOKEN в .env
- Проверить сетевое подключение

Уведомления не отправляются:
- Проверить наличие group.json с правильным group_id
- Проверить логи планировщика: grep "Scheduler" logs/dodo_bot.log
- Проверить часовой пояс Europe/Moscow
- Проверить инициализацию job_queue

Ошибки Google Sheets:
- Проверить наличие service_account.json
- Проверить SPREADSHEET_ID в .env
- Проверить доступ сервисного аккаунта к таблице
- Проверить квоты API

Ошибки Gemini API:
- Проверить GEMINI_API_KEY в .env
- Проверить квоты API и биллинг
- Просмотреть логи ошибок

Веб-приложение не загружается:
- Проверить systemctl status dodo-webapp
- Проверить, что порт 5001 не используется
- Проверить логи webapp: sudo journalctl -u dodo-webapp -n 100
- Тестировать health endpoint: curl http://localhost:5001/health


5.2 ТЕХНИКИ ОТЛАДКИ
-------------------

Включить отладочное логирование:
В main.py изменить:
logger.setLevel(logging.DEBUG)

Просмотр логов в реальном времени:
sudo journalctl -u dodo-bot -f

Тестирование конкретного обработчика:
Отправить команду боту и наблюдать за логами

Проверка файлов данных:
cat data/users.json | jq
cat data/group.json | jq
cat data/medical_info.json | jq

Тестирование подключения к Google Sheets:
python3
>>> from services.sheets import get_all_employees
>>> import asyncio
>>> asyncio.run(get_all_employees())


5.3 ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ
-----------------------------------

Уменьшение вызовов API:
- Использовать кэширование sheet_manager.py
- Группировать запросы где возможно
- Кэшировать часто используемые данные

Управление памятью:
- Мониторить с помощью: systemctl status dodo-bot | grep Memory
- Периодически перезапускать сервисы при необходимости
- Проверять утечки памяти в логах

Время отклика:
- Правильно использовать async/await
- Избегать блокирующих операций
- Откладывать тяжелую обработку на фоновые задания


--------------------------------------------------------------------------------
6. СООБРАЖЕНИЯ БЕЗОПАСНОСТИ
--------------------------------------------------------------------------------

6.1 КОНФИДЕНЦИАЛЬНЫЕ ДАННЫЕ
----------------------------

Переменные окружения:
- Никогда не коммитить .env в git
- Использовать .env.example как шаблон
- Ограничить права доступа к файлу: chmod 600 .env

Сервисный аккаунт:
- Никогда не коммитить service_account.json
- Ограничить права доступа к файлу: chmod 600 service_account.json
- Периодически ротировать ключи

Данные пользователей:
- data/users.json содержит ID пользователей (конфиденциально)
- Безопасно резервировать
- Не выводить в логи


6.2 КОНТРОЛЬ ДОСТУПА
--------------------

Права менеджера:
- Жестко заданные фамилии в medical.py
- На основе ролей в medical_info.json
- Статус администратора группы Telegram

Групповые команды:
- Ограничены для администраторов/менеджеров
- group_restriction_handler в main.py
- Предотвращает несанкционированный доступ


6.3 ВАЛИДАЦИЯ ВВОДА
-------------------

Валидация даты:
- Формат: ДД.ММ.ГГГГ
- Проверяется в medical.py input_date()
- Отклоняет недействительные даты

Данные Callback:
- Проверяются в обработчиках
- Сопоставление паттернов в CallbackQueryHandler
- Предотвращает атаки инъекций


6.4 БЕЗОПАСНОСТЬ API
--------------------

Токен Telegram бота:
- Хранить в секрете
- Ротировать при компрометации
- Использовать переменную окружения

Сервисный аккаунт Google:
- Минимальные права (чтение/запись конкретной таблицы)
- Не делиться учетными данными
- Мониторить использование

Ключ API Gemini:
- Хранить в секрете
- Мониторить использование и затраты
- Установить лимиты использования


--------------------------------------------------------------------------------
7. МОНИТОРИНГ И ОБСЛУЖИВАНИЕ
--------------------------------------------------------------------------------

7.1 ПРОВЕРКИ ЗДОРОВЬЯ
---------------------

Здоровье бота:
systemctl is-active dodo-bot && echo "OK" || echo "FAILED"

Здоровье веб-приложения:
curl http://localhost:5001/health

Полный статус:
sudo systemctl status dodo-bot dodo-webapp


7.2 МОНИТОРИНГ ЛОГОВ
---------------------

Отслеживание ошибок:
tail -f logs/dodo_bot_errors.log

Мониторинг уведомлений:
grep "notification" logs/dodo_bot.log

Проверка вызовов API:
grep "Google Sheets" logs/dodo_bot.log
grep "Gemini" logs/dodo_bot.log


7.3 РЕГУЛЯРНЫЕ ЗАДАЧИ ОБСЛУЖИВАНИЯ
-----------------------------------

Ежедневно:
□ Проверить статус сервисов
□ Просмотреть логи ошибок
□ Проверить отправку уведомлений

Еженедельно:
□ Просмотреть все логи
□ Проверить дисковое пространство
□ Проверить создание резервных копий
□ Обновить медицинские данные

Ежемесячно:
□ Обновить зависимости
□ Просмотреть использование API
□ Очистить старые резервные копии
□ Проверить обновления безопасности


7.4 МЕТРИКИ ДЛЯ ОТСЛЕЖИВАНИЯ
-----------------------------

Использование:
- Количество зарегистрированных пользователей
- Команд в день
- Отправленных уведомлений
- Вызовов API

Производительность:
- Время отклика
- Использование памяти
- Использование CPU
- Использование диска

Ошибки:
- Частота ошибок
- Неудачные уведомления
- Ошибки API


--------------------------------------------------------------------------------
8. СПРАВОЧНИК API
--------------------------------------------------------------------------------

8.1 GOOGLE SHEETS API
----------------------

Аутентификация:
- Сервисный аккаунт (OAuth 2.0)
- Области: spreadsheets.readonly или spreadsheets

Ограничения скорости:
- 100 запросов за 100 секунд на пользователя
- 500 запросов за 100 секунд на проект

Обработка ошибок:
- gspread.exceptions.APIError
- Повтор с экспоненциальной задержкой


8.2 TELEGRAM BOT API
--------------------

Используемые методы:
- sendMessage: Отправка текстовых сообщений
- sendPhoto: Отправка фотографий
- editMessageText: Редактирование существующих сообщений
- answerCallbackQuery: Ответ на нажатия кнопок
- getChatAdministrators: Проверка статуса администратора

Ограничения скорости:
- 30 сообщений в секунду
- 20 сообщений в минуту одному пользователю

Обработка ошибок:
- telegram.error.TelegramError
- telegram.error.BadRequest
- telegram.error.TimedOut


8.3 GEMINI API
--------------

Модель: gemini-2.5-flash

Методы:
- generateContent: Анализ текста и изображений

Ограничения скорости:
- Зависит от плана
- Мониторить в Google Cloud Console

Обработка ошибок:
- google.api_core.exceptions.GoogleAPIError
- Обработка превышения квоты
- Резервный вариант на анализ только текста


--------------------------------------------------------------------------------
9. ГЛОССАРИЙ
--------------------------------------------------------------------------------

Термины:
- Handler (Обработчик): Функция, обрабатывающая обновления Telegram
- ConversationHandler: Поток многошагового взаимодействия
- Callback Query: Событие нажатия кнопки
- Inline Keyboard: Кнопки, прикрепленные к сообщениям
- Reply Keyboard: Кнопки внизу чата
- Job Queue: Планировщик для задач по времени
- Service (Сервис): Модуль бизнес-логики
- Systemd: Менеджер сервисов Linux
- Gunicorn: HTTP-сервер Python WSGI

Типы файлов:
- .py: Исходный код Python
- .json: Формат хранения данных
- .service: Определение сервиса Systemd
- .sh: Shell-скрипт
- .env: Переменные окружения
- .log: Файл лога


--------------------------------------------------------------------------------
10. ПОДДЕРЖКА И РЕСУРСЫ
--------------------------------------------------------------------------------

Документация:
- python-telegram-bot: https://docs.python-telegram-bot.org/
- gspread: https://docs.gspread.org/
- Flask: https://flask.palletsprojects.com/
- Google Gemini: https://ai.google.dev/docs

Внутренняя документация:
- README.md: Обзор проекта
- DEPLOYMENT.md: Руководство по развертыванию
- MAINTENANCE.md: Процедуры обслуживания
- QUICKREF.md: Краткий справочник

Расположение логов:
- Приложение: /home/ubuntu/dodo_bot/logs/
- Systemd: sudo journalctl -u dodo-bot

Контакт:
- Для технических проблем: Сначала проверьте логи
- Для запросов функций: Задокументируйте требования
- Для багов: Предоставьте логи и шаги воспроизведения


================================================================================
                            КОНЕЦ ДОКУМЕНТАЦИИ
================================================================================

Версия документа: 1.0
Последнее обновление: 27 ноября 2025
Поддерживается: Anubhav

Для обновления этой документации редактируйте DEVELOPER_MANUAL_RU.txt в корне проекта.
